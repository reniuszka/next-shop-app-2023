import { GetStaticPropsContext, InferGetStaticPropsType } from "next";
import { useRouter } from "next/router";
import { ProductDetails } from "../../components/Product";
import Link from "next/link";
import { serialize } from "next-mdx-remote/serialize";
// import { MDXRemoteSerializeResult } from "next-mdx-remote";
import { MarkdownResult } from "../../utils";
const ProductIdPage = ({
  data,
}: InferGetStaticPropsType<typeof getStaticProps>) => {
  // router jest po stronie klienta
  const router = useRouter();

  //jezeli nie ma data
  if (!data) {
    return <div>no data to display</div>;
  }

  // console.log("router", router);

  return (
    <>
      <Link href={"/ssg_products"}>Go back</Link>
      <ProductDetails
        data={{
          id: data.id,
          title: data.title,
          thumbnailAlt: data.title,
          thumbnailUrl: data.image,
          description: data.description,
          longDescription: data.longDescription,
          rating: data.rating.rate,
        }}
      />
    </>
  );
  // return <div>{router.query.productId}</div>;
};
//chlopaki stworzyli typ by infetrowac TS typ z getstaticpaths
export type InferGetStaticPathsType<T> = T extends () => Promise<{
  paths: Array<{ params: infer R }>;
}>
  ? R
  : never;

// uÅ¼ycie - required by NExt getStaticPaths
//nextjs.org/docs/messages/invalid-getstaticpaths-value
//generujemy id all dostepnych produktow by wygenerowac ich pathy: products/2
export const getStaticPaths = async () => {
  const res = await fetch("https://naszsklep-api.vercel.app/api/products/");
  const data: StoreApiResponse[] = await res.json();

  return {
    paths: data.map((product) => {
      return {
        params: {
          productId: product.id.toString(),
        },
      };
    }),
    //by wygenerowac storne produscts/1
    // paths: [
    //   {
    //     params: {
    //       productId: "1",
    //     },
    //   },
    // ],
    fallback: false,
  };
};
//za wczasu chcemy wygenerowac id ktore sa dostepne za pomoca static props
//by dostac sie do id - gdy mamy zdefiniowane w drzewie katalogowym specjalny plik [].tsx to jego pole jest przekazywane do get static props - jako params mamy dostepne wszyskie parametry -> dodaj typ i najedz na niego i to jest generyk i dodaje mu typ
// export const getStaticProps = async ({
//   params,
// }: : InferGetStaticPaths<typeof getStaticPaths>) => {
//   // }: GetStaticPropsContext<{ productId: string }>) => {
//   //spr czy params istnije
//   if (!params?.productId) {
//     return { props: {}, notFound: true };
//   }
//   const res = await fetch(
//     `https://naszsklep-api.vercel.app/api/products//${params?.productId}`
//   );
//   const data: StoreApiResponse | null = await res.json();
//   // console.log("daaaata", data);

//   return {
//     props: {
//       data,
//     },
//   };
// };

export const getStaticProps = async ({
  params,
}: GetStaticPropsContext<InferGetStaticPathsType<typeof getStaticPaths>>) => {
  if (!params?.productId) {
    return {
      props: {},
      notFound: true,
    };
  }
  const res = await fetch(
    `https://naszsklep-api.vercel.app/api/products//${params?.productId}`
  );
  const data: StoreApiResponse | null = await res.json();
  if (!data) {
    return {
      props: {},
      notFound: true,
    };
  }
  // console.log("daaaata", data);

  //next-mdx-remote dla data.longDescription
  // const skompilowanyMarkdown = await serialize(data.longDescription);

  return {
    props: {
      // to jest to samo co data lub data:data lub data: ...{data}
      data: {
        ...data,
        //nadpisujemy
        longDescription: await serialize(data.longDescription),
      },
    },
  };
};

// Generated by https://quicktype.io
interface StoreApiResponse {
  id: number;
  title: string;
  price: number;
  description: string;
  longDescription: MarkdownResult;
  category: string;
  image: string;
  rating: {
    rate: number;
    count: number;
  };
}

export default ProductIdPage;
